///  Modern JavaScript tutorial  ///

// При создании примитивного значения типа 5 мы получаем число, когда мы хотим получить доступ к свойства создаётся временный ОБЪЕКТ-обёртка
// с использованием встроенного конструктора  number, предоставит методы.

// 8.1 Прототипное наследование

// Прототипное наследование — это возможность языка, которая помогает  создать новый объект на оснвое другого.
// В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации),
// которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип»
// Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа.
//  В программировании такой механизм называется «прототипным наследованием».
//   Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]
//   Обратите внимание, что __proto__ — не то же самое, что [[Prototype]]. Это геттер/сеттер для него.
//   let animal = {
//     eats: true
//   };
//   let rabbit = {
//     jumps: true
//   };
//   rabbit.__proto__ = animal; // (*)
//   // теперь мы можем найти оба свойства в rabbit:
//   alert( rabbit.eats ); // true (**)
//   alert( rabbit.jumps ); // true
//   Здесь строка (*) устанавливает animal как прототип для rabbit.
//   Затем, когда alert пытается прочитать свойство rabbit.eats (**), его нет в rabbit,
//   поэтому JavaScript следует по ссылке [[Prototype]] и находит его в animal (смотрите снизу вверх):
//   Здесь мы можем сказать, что "animal является прототипом rabbit" или "rabbit прототипно наследует от animal".

//   Есть  два ограничения:
// Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
// Значение __proto__ может быть объектом или null. Другие типы игнорируются.
// Это вполне очевидно, но всё же: может быть только один [[Prototype]]. Объект не может наследоваться от двух других объектов.

// Операция записи не использует прототип
// Прототип используется только для чтения свойств.
// Операции записи/удаления работают напрямую с объектом.
// Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть, это, фактически, вызов функции.

// Операция записи не использует прототип НЕ ПРОЙДЕНО НЕ ПРОЙДЕНО НЕ ПРОЙДЕНО

// Значение «this»
// Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

// Цикл for…in
// Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
// Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key)
// : он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.
// Почти все остальные методы получения ключей/значений игнорируют унаследованные свойства
// Почти все остальные методы, получающие ключи/значения, такие как Object.keys, Object.values и другие – игнорируют унаследованные свойства.
// Они учитывают только свойства самого объекта, не его прототипа.

// Итого
// В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
// Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер,
//      есть другие способы, которые скоро будут рассмотрены).
// Объект, на который ссылается [[Prototype]], называется «прототипом».
// Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
// Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
// Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj.
// Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
// Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений
// работают только с собственными свойствами объекта.

// 8.2 F.prototype

// Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().
// Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
// Обратите внимание, что F.prototype означает обычное свойство с именем "prototype" для F.
// Это ещё не «прототип объекта», а обычное свойство F с таким именем.
// Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее:
// "При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".

// F.prototype по умолчанию, свойство constructor
// У каждой функции по умолчанию уже есть свойство "prototype".
// По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.
// самое важное о свойстве "constructor" это то, что…
// …JavaScript сам по себе не гарантирует правильное значение свойства "constructor".
// Итого
// В этой главе мы кратко описали способ задания [[Prototype]] для объектов, создаваемых с
// помощью функции-конструктора. Позже мы рассмотрим, как можно использовать эту возможность.
// Всё достаточно просто. Выделим основные моменты:
// Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().
// Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
// Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.
// В обычных объектах prototype не является чем-то особенным:
// let user = {
//   name: "John",
//   prototype: "Bla-bla" // никакой магии нет - обычное свойство
// };
// По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор объекта через свойство "constructor".

// 8.3 Встроенные прототипы

// Object.prototype;
// краткая нотация obj = {} – это то же самое, что и obj = new Object(), где Object – встроенная функция-конструктор
// для объектов с собственным свойством prototype, которое ссылается на огромный объект с методом toString и другими.

// Другие встроенные прототипы
// Примитивы
// Самое сложное происходит со строками, числами и булевыми значениями.
// Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный
// объект-обёртка с использованием встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.
// Значения null и undefined не имеют объектов-обёрток

// Изменение встроенных прототипов
// Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:
// String.prototype.show = function() {
//   alert(this);
// };
// "BOOM!".show(); // BOOM! Это плохая идея.
// Важно:
// Прототипы глобальны, поэтому очень легко могут возникнуть конфликты.
// Если две библиотеки добавляют метод String.prototype.show, то одна из них перепишет метод другой.
// Так что, в общем, изменение встроенных прототипов считается плохой идеей.
// Так что, в общем, изменение встроенных прототипов считается плохой идеей.
// В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.
// Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript,
// но ещё не поддерживается текущим движком JavaScript.
// Заимствование у прототипов
// Итого
// Все встроенные объекты следуют одному шаблону:
// Методы хранятся в прототипах (Array.prototype, Object.prototype, Date.prototype и т.д.).
// Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).
// Примитивы также хранят свои методы в прототипах объектов-обёрток: Number.prototype, String.prototype,
// Boolean.prototype. Только у значений undefined и null нет объектов-обёрток.
// Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их.
// Единственная допустимая причина – это добавление нового метода из стандарта, который ещё не поддерживается движком JavaScript.

// 8.4 Методы прототипов, объекты без свойства __proto__

// Современные методы это:
// Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto,
//  и необязательными дескрипторами свойств descriptors.
// Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
// Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
// let animal = {
//     eats: true
//   };
//   // создаём новый объект с прототипом animal
//   let rabbit = Object.create(animal);
//   alert(rabbit.eats); // true
//   alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit
//   Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}

//   "Простейший" объект

//   Итого
// Современные способы установки и прямого доступа к прототипу это:

// Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto
// (может быть null), и необязательными дескрипторами свойств.
// Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj (то же самое, что и геттер __proto__).
// Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto (то же самое, что и сеттер __proto__).
// Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные
// пользователями ключи в объекте. Как минимум потому, что пользователь может ввести "__proto__"
// как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы.
// Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.
// Кроме этого, Object.create даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:
// let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
// Мы также ясно увидели, что __proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.
// Мы можем создавать объекты без прототипов с помощью Object.create(null). Такие объекты можно
//  использовать как «чистые словари», у них нет проблем с использованием строки "__proto__" в качестве ключа.
// Ещё методы:
// Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех
// перечисляемых собственных строковых ключей/значений/пар ключ-значение.
// Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.
// Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.
// Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
// obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.
// Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают
// «собственные» свойства. Если мы хотим получить и унаследованные, можно воспользоваться циклом for..in.

// 9.1 Класс: базовый синтаксис( конструкция «class»)

// В ООП класс – это расширяемый шаблон кода для создания объектов, который
// устанавливает в них начальные значения (свойства) и реализацию поведения (методы).
// Синтаксис «class»
// class MyClass {
//     // методы класса
//     constructor() { ... }
//     method1() { ... }
//     method2() { ... }
//     method3() { ... }
//     ...
//   }
//   Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.
//   При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.
//   Когда вызывается new User("Иван"):
// Создаётся новый объект.
// constructor запускается с заданным аргументом и сохраняет его в this.name.
//   Что такое класс?
//   В JavaScript класс – это разновидность функции.
//   конструкция class User {...}:
// Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции
//  берётся из метода constructor (она будет пустой, если такого метода нет).
// Сохраняет все методы, такие как sayHi, в User.prototype.
// Не просто синтаксический сахар
// Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[FunctionKind]]:"classConstructor".
// Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".
// И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.
// Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

// 9.2 Наследование классов
// Для того, чтобы наследовать класс от другого, мы должны использовать ключевое слово "extends"
// и указать название родительского класса перед {..}.
// class Rabbit extends Animal {
//   После extends разрешены любые выражения
//   Переопределение методов
//   Ключевое слово extends работает, используя прототипы.
//   Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. Так что если метод не найден
//   в Rabbit.prototype, JavaScript берёт его из Animal.prototype.

//  9.3 Статические свойства и методы
//  Мы также можем присвоить метод самой функции-классу, а не её "prototype". Такие методы называются статическими.
//  В классе такие методы обозначаются ключевым словом static, например:\
//  class User {
//   static staticMethod() {
//     alert(this === User);
//   }
// }
// User.staticMethod(); // true

// Статические свойства
// class Article {
//   static publisher = "Илья Кантор";
// }
// alert( Article.publisher ); // Илья Кантор

// Наследование статических свойств и методов (static)

// Rabbit extends Animal создаёт две ссылки на прототип:
// Функция Rabbit прототипно наследует от функции Animal.
// Rabbit.prototype прототипно наследует от Animal.prototype.
// Итого
// Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.
// Например, метод для сравнения двух статей Article.compare(article1, article2) или фабричный метод Article.createTodays().
// В объявлении класса они помечаются ключевым словом static.
// Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.
// Синтаксис:
// class MyClass {
//   static property = ...;

//   static method() {
//     ...
//   }
// }
// Технически, статическое объявление – это то же самое, что и присвоение классу:
// MyClass.property = ...
// MyClass.method = ...
// Статические свойства и методы наследуются.
// Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.

// 9.4 Приватные и защищённые методы и свойства

// Внутренний и внешний интерфейсы
// В объектно-ориентированном программировании свойства и методы разделены на 2 группы:
// Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
// Внешний интерфейс – методы и свойства, доступные снаружи класса.
// В JavaScript есть два типа полей (свойств и методов) объекта:
// Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
// Приватные: доступны только внутри класса. Они для внутреннего интерфейса.

// Защищённое свойство «waterAmount»
// Защищённые свойства обычно начинаются с префикса _.
// Свойство только для чтения «power»
// Защищённые поля наследуются
// Если мы унаследуем class MegaMachine extends CoffeeMachine, ничто не помешает нам обращаться к
// this._waterAmount или this._power из методов нового класса.
// Таким образом защищённые методы, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.

// Приватное свойство «#waterLimit»
// Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
// На уровне языка # является специальным символом, который означает, что поле приватное.
//  Мы не можем получить к нему доступ извне или из наследуемых классов.
// Приватные поля не конфликтуют с публичными. У нас может быть два поля одновременно – приватное #waterAmount и публичное waterAmount.
// Важно:
// Приватные поля особенные.
// Как мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]:
// class User {
//   ...
//   sayHi() {
//     let fieldName = "name";
//     alert(`Hello, ${this[fieldName]}`);
//   }
// }
// С приватными свойствами такое невозможно: this['#name'] не работает. Это ограничение синтаксиса сделано для обеспечения приватности.

// Итого
// В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.
// Это даёт следующие выгоды:
// Защита для пользователей, чтобы они не выстрелили себе в ногу
// Поддерживаемость
// Если мы чётко отделим внутренний интерфейс, то разработчик класса сможет свободно менять его
// внутренние свойства и методы, даже не информируя пользователей…
// Сокрытие сложности
// Всегда удобно, когда детали реализации скрыты, и доступен простой, хорошо документированный внешний интерфейс.
// Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:
// Защищённые поля имеют префикс _. Это хорошо известное соглашение, не поддерживаемое на уровне языка.
// Программисты должны обращаться к полю, начинающемуся с _, только из его класса и классов, унаследованных от него.
// Приватные поля имеют префикс #. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.
// В настоящее время приватные поля не очень хорошо поддерживаются в браузерах, но можно использовать полифил.

// 9.5 Расширение встроенных классов
// От встроенных классов, таких как Array, Map и других, тоже можно наследовать.

// Отсутствие статического наследования встроенных классов
// встроенные классы – исключение. Они не наследуют статические методы друг друга.

// 9.7 Примеси
// В JavaScript можно наследовать только от одного объекта. Объект имеет единственный [[Prototype]].
// И класс может расширить только один другой класс.

//  Примесь – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.
//  Другими словами, примесь определяет методы, которые реализуют определённое поведение.
//   Мы не используем примесь саму по себе, а используем её, чтобы добавить функциональность другим классам.
// // примесь
// let sayHiMixin = {
//     sayHi() {
//       alert(`Привет, ${this.name}`);
//     },
//     sayBye() {
//       alert(`Пока, ${this.name}`);
//     }
//   };
//  // использование:
//   class User {
//     constructor(name) {
//       this.name = name;
//     }
//   }
//   // копируем методы
//   Object.assign(User.prototype, sayHiMixin);
//  // теперь User может сказать Привет
//   new User("Вася").sayHi(); // Привет, Вася!
// Это не наследование, а просто копирование методов.
// Примеси могут наследовать друг друга.

// EventMixin
// Примесь добавит метод .trigger(name, [data]) для генерации события. Аргумент name – это имя события,
// за которым могут следовать другие аргументы с данными для события.
// Также будет добавлен метод .on(name, handler), который назначает обработчик для события с заданным именем.
// Обработчик будет вызван, когда произойдёт событие с указанным именем name, и получит данные из .trigger.
// …и метод .off(name, handler), который удаляет обработчик указанного события.

// 3 метода:
// .on(eventName, handler) – назначает функцию handler, чтобы обработать событие с заданным именем.
// Обработчики хранятся в свойстве _eventHandlers, представляющим собой объект, в котором имя события является ключом,
// а массив обработчиков – значением.
// .off(eventName, handler) – убирает функцию из списка обработчиков.
// .trigger(eventName, ...args) – генерирует событие: все назначенные обработчики из _eventHandlers[eventName]
// вызываются, и ...args передаются им в качестве аргументов.

// Итого
// Примесь – общий термин в объектно-ориентированном программировании: класс, который содержит в себе методы для других классов.
// Некоторые другие языки допускают множественное наследование. JavaScript не поддерживает множественное наследование,
// но с помощью примесей мы можем реализовать нечто похожее, скопировав методы в прототип.
// Мы можем использовать примеси для расширения функциональности классов, например, для обработки событий, как мы сделали это выше.
// С примесями могут возникнуть конфликты, если они перезаписывают существующие методы класса. Стоит помнить об этом и
// быть внимательнее при выборе имён для методов примеси, чтобы их избежать.
